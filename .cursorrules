# Next.js SSR 部署规则

## 核心原则

### 1. SSR 模式要求
- **所有页面必须使用 SSR（Server-Side Rendering）模式**
- 使用 `getServerSideProps` 而不是 `getStaticProps` 或客户端渲染
- 确保所有内容在服务器端渲染，直接写入 HTML
- 禁止使用客户端渲染（CSR）来加载主要内容

### 2. 禁止文件系统依赖
- **禁止在 SSR 中使用文件系统（fs）模块**
- Vercel 的 serverless 环境不支持文件系统访问
- 所有动态内容必须硬编码到 JavaScript 文件中
- 使用硬编码对象（如 `HARDCODED_POST_METADATA`）存储内容

### 3. 内容硬编码
- **所有内容必须硬编码到 JavaScript 文件**
- Blog posts、Examples、Legal 内容等都应硬编码
- 使用模板字符串（template literals）存储 HTML 内容
- 避免运行时读取外部 HTML 文件

## 具体实现规则

### 页面实现
```javascript
// ✅ 正确：使用 getServerSideProps 和动态导入
export async function getServerSideProps({ params }) {
    const { slug } = params;
    const { getPostHtmlBySlug } = await import('../../lib/posts');
    const { title, description, html } = getPostHtmlBySlug(slug);
    return { props: { title, description, html } };
}

// ❌ 错误：使用 getStaticProps（SSG）或 fs 模块
export async function getStaticProps({ params }) {
    const html = fs.readFileSync(`./posts/${slug}.html`, 'utf8');
}
```

### 数据源实现
```javascript
// ✅ 正确：硬编码内容
const HARDCODED_POST_METADATA = {
    'post-slug': {
        title: 'Post Title',
        description: 'Post description',
        html: `<h1>Post Title</h1><p>Content...</p>`
    }
};

export function getPostHtmlBySlug(slug) {
    const hardcoded = HARDCODED_POST_METADATA[slug];
    return {
        title: hardcoded.title,
        description: hardcoded.description,
        html: hardcoded.html
    };
}

// ❌ 错误：使用 fs 模块读取文件
import fs from 'fs';
export function getPostHtmlBySlug(slug) {
    const html = fs.readFileSync(`./posts/${slug}.html`, 'utf8');
    return { html };
}
```

### 内容渲染
```javascript
// ✅ 正确：内容直接通过 props 传递
export default function Page({ title, html }) {
    return (
        <>
            <h1>{title}</h1>
            <div dangerouslySetInnerHTML={{ __html: html }} />
        </>
    );
}

// ❌ 错误：使用客户端状态加载内容
const [content, setContent] = useState(null);
useEffect(() => { fetchContent(); }, []);
```

### 动态导入
```javascript
// ✅ 正确：在 getServerSideProps 中动态导入
export async function getServerSideProps({ params }) {
    const { getPostHtmlBySlug } = await import('../../lib/posts');
    const data = getPostHtmlBySlug(params.slug);
    return { props: { data } };
}

// ❌ 错误：在组件顶层直接导入
import { getPostHtmlBySlug } from '../../lib/posts';
```

### 错误处理
```javascript
// ✅ 正确：提供降级方案
export async function getServerSideProps({ params }) {
    try {
        const { getPostHtmlBySlug } = await import('../../lib/posts');
        const data = getPostHtmlBySlug(params.slug);
        return { props: { data } };
    } catch (error) {
        console.error('Error:', error);
        return { 
            props: { 
                data: {
                    title: 'Error',
                    html: '<p>Content not available.</p>'
                }
            } 
        };
    }
}
```

## Vercel 部署规则

### Serverless 环境限制
- **禁止使用文件系统操作**：`fs.readFileSync()`, `fs.readdirSync()` 等
- **禁止使用同步文件操作**：所有同步操作在 serverless 中不可靠
- **使用硬编码数据**：所有内容必须编译到 JavaScript bundle 中

### API 路由
- **放在 `pages/api/` 目录**：所有 API 路由必须在这里
- **使用 Serverless Functions**：Vercel 会自动识别为 serverless functions
- **不要使用 Express**：Vercel 不运行 `server.js`，只运行 `api/*.js`

### 环境变量
- **使用环境变量**：敏感信息通过 `process.env` 访问
- **在 Vercel 中配置**：在 Vercel Dashboard 中设置环境变量
- **不要硬编码敏感信息**：API keys、数据库连接等

## 页面完整性要求

### 每个页面必须包含：
1. ✅ **SEO Head 组件**：包含 title、description、canonical URL
2. ✅ **结构化数据**：JSON-LD schema markup
3. ✅ **完整内容**：所有内容通过 SSR 渲染，不使用客户端加载
4. ✅ **图片优化**：使用 Next.js Image 组件，包含 alt 文本
5. ✅ **响应式设计**：确保移动端友好
6. ✅ **错误处理**：提供降级方案，避免 404 或空白页面

### 页面结构示例
```javascript
export default function Page({ data }) {
    return (
        <>
            <SEOHead
                title={data.title}
                description={data.description}
                url={`/page/${data.slug}`}
                image={data.image}
            />
            <Head>
                <script
                    type="application/ld+json"
                    dangerouslySetInnerHTML={{
                        __html: JSON.stringify({
                            '@context': 'https://schema.org',
                            '@type': 'Article',
                            headline: data.title,
                            description: data.description
                        })
                    }}
                />
            </Head>
            <main>
                <h1>{data.title}</h1>
                <div dangerouslySetInnerHTML={{ __html: data.html }} />
            </main>
        </>
    );
}
```

## 常见问题解决方案

### 问题 1：页面显示 404 错误
**原因**：使用文件系统读取内容，在 Vercel serverless 环境中不可靠
**解决方案**：将所有内容硬编码到 JavaScript 文件中

### 问题 2：页面内容为空
**原因**：使用客户端渲染加载内容
**解决方案**：使用 `getServerSideProps` 在服务器端获取所有内容

### 问题 3：图片不显示
**原因**：图片路径错误或未使用 Next.js Image 组件
**解决方案**：使用绝对路径（以 `/` 开头），使用 Next.js Image 组件

## 验证清单

### 部署前检查：
- [ ] 所有页面使用 `getServerSideProps`
- [ ] 所有数据源使用硬编码，不使用文件系统
- [ ] 所有内容通过 props 传递，不使用客户端状态
- [ ] 所有图片使用 Next.js Image 组件
- [ ] 所有页面包含 SEO Head 和结构化数据

### 部署后验证：
- [ ] 查看页面源码，确认所有内容在 HTML 中
- [ ] 使用 Google Search Console 测试页面抓取
- [ ] 检查移动端显示是否正常
- [ ] 确认所有链接正常工作

## 总结

**核心原则**：
1. **SSR 优先**：所有页面使用 SSR 模式
2. **硬编码数据**：避免文件系统依赖
3. **内容完整**：确保所有内容在 HTML 源码中可见
4. **错误处理**：提供降级方案，避免空白页面

**关键规则**：
- 禁止在 SSR 中使用 `fs` 模块
- 所有动态内容必须硬编码到 JavaScript 文件
- 使用 `getServerSideProps` 而不是 `getStaticProps`
- 确保所有内容通过 props 传递，不使用客户端状态

